<?xml version="1.0" encoding="UTF-8" ?>

<Schemas xmlns="urn:com.io7m.trasco.database.statements:1:0">

  <Parameters>
    <Parameter name="search.language"
               type="STRING"/>
  </Parameters>

  <Schema versionCurrent="0">
    <Comment>
      The northpike role is a least-privilege role that can perform only those
      operations required to run the system and no others.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The northpike_none role is a no-privilege role that cannot perform any
      actions.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike_none;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike_none WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The northpike_read_only role is a read-only role that cannot write to
      anything.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike_read_only;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike_read_only WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The schema version table stores the current version of the database
      schema. Implementations are expected to query this table on connecting to
      the database in order to ensure that the calling code is compatible with
      the tables in the database.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE schema_version (
  version_lock            CHAR(1) NOT NULL DEFAULT 'X',
  version_application_id  TEXT    NOT NULL,
  version_number          BIGINT  NOT NULL,

  CONSTRAINT check_lock_primary
    PRIMARY KEY (version_lock),

  CONSTRAINT check_lock_locked
    CHECK (version_lock = 'X')
)
]]>
    </Statement>
  </Schema>

  <Schema versionCurrent="1">
    <Comment>
      The users table stores the current set of users. The name field is neither
      authoritative, nor expected to be unique, because the external identity
      server is the authoritative source for names.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE users (
  id    UUID   NOT NULL PRIMARY KEY,
  name  TEXT   NOT NULL,
  roles TEXT[] NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE ON users TO northpike
    </Statement>
    <Statement>
      GRANT SELECT ON users TO northpike_read_only
    </Statement>

    <Comment>
      The scm_providers table stores definitions for the available SCM
      providers.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE scm_providers (
  sp_id           BIGINT        NOT NULL GENERATED ALWAYS AS IDENTITY,
  sp_name         VARCHAR(1024) NOT NULL,
  sp_description  TEXT          NOT NULL,
  sp_url          TEXT          NOT NULL,

  CONSTRAINT scm_providers_primary_key
    PRIMARY KEY (sp_id),

  CONSTRAINT scm_providers_name_unique
    UNIQUE (sp_name),

  CONSTRAINT scm_providers_name_valid
    CHECK (sp_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Comment>
      The repository_credentials_type_t type represents the possible
      credentials.
    </Comment>

    <Statement><![CDATA[
CREATE TYPE repository_credentials_type_t AS ENUM(
  'REPOSITORY_CREDENTIALS_USERNAME_PASSWORD',
  'REPOSITORY_CREDENTIALS_NONE'
);
]]></Statement>

    <Comment>
      The repositories table stores the set of repositories used for builds. The
      server will regularly consult the repositories defined here to find new
      commits to build.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repositories (
  r_id                       UUID                           NOT NULL,
  r_provider                 BIGINT                         NOT NULL,
  r_url                      VARCHAR(8192)                  NOT NULL,
  r_credentials_type         repository_credentials_type_t  NOT NULL,
  r_credentials_username     VARCHAR(8192),
  r_credentials_password     VARCHAR(8192),
  r_last_successful_update   TIMESTAMP WITH TIME ZONE,

  -- [jooq ignore start]
  CONSTRAINT repositories_credentials_type_values_present CHECK (
    CASE
      WHEN r_credentials_type = 'REPOSITORY_CREDENTIALS_USERNAME_PASSWORD' THEN
        ((r_credentials_username IS NOT NULL) AND (r_credentials_password IS NOT NULL))
      WHEN r_credentials_type = 'REPOSITORY_CREDENTIALS_NONE' THEN
        't'::boolean
      ELSE
        'f'::boolean
    END
  ),
  -- [jooq ignore stop]

  CONSTRAINT repositories_primary_key
    PRIMARY KEY (r_id),

  CONSTRAINT repositories_provider_exists
    FOREIGN KEY (r_provider) REFERENCES scm_providers (sp_id),

  CONSTRAINT repositories_url_unique
    UNIQUE (r_url)
)
]]></Statement>

    <Comment>
      The repository_commit_authors table uniquely (within a single repository)
      identifies authors of commits.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repository_commit_authors (
  rca_id     BIGINT   NOT NULL GENERATED ALWAYS AS IDENTITY,
  rca_name   TEXT     NOT NULL,
  rca_email  TEXT     NOT NULL,

  CONSTRAINT repository_commit_authors_primary_key
    PRIMARY KEY (rca_id)
)
]]></Statement>

    <Statement><![CDATA[
-- [jooq ignore start]
CREATE UNIQUE INDEX repository_commit_authors_unique
  ON repository_commit_authors (rca_name, LOWER(rca_email))
-- [jooq ignore stop]
]]></Statement>

    <Comment>
      The repository_commits table stores information about each commit in a
      repository.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repository_commits (
  rc_id                     BIGINT                    NOT NULL GENERATED ALWAYS AS IDENTITY,
  rc_repository             UUID                      NOT NULL,
  rc_commit_id              VARCHAR(8192)             NOT NULL,
  rc_commit_time_created    TIMESTAMP WITH TIME ZONE  NOT NULL,
  rc_commit_time_received   TIMESTAMP WITH TIME ZONE  NOT NULL,
  rc_commit_author          BIGINT                    NOT NULL,
  rc_commit_message_subject TEXT                      NOT NULL,
  rc_commit_message_body    TEXT                      NOT NULL,

  CONSTRAINT repository_commits_primary_key
    PRIMARY KEY (rc_id),

  CONSTRAINT repository_commits_unique
    UNIQUE (rc_repository, rc_commit_id),

  CONSTRAINT repository_commits_repository_exists
    FOREIGN KEY (rc_repository) REFERENCES repositories (r_id),

  CONSTRAINT repository_commits_author_exists
    FOREIGN KEY (rc_commit_author) REFERENCES repository_commit_authors (rca_id),

  CONSTRAINT repository_commits_id_valid
    CHECK (rc_commit_id ~ '^[a-f0-9]+$')
)
]]></Statement>

    <Comment>
      The repository_commit_tags table stores information about each tag in a
      repository.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repository_commit_tags (
  rct_id      BIGINT         NOT NULL GENERATED ALWAYS AS IDENTITY,
  rct_tag     VARCHAR(8192)  NOT NULL,
  rct_commit  BIGINT         NOT NULL,

  CONSTRAINT repository_commit_tags_primary_key
    PRIMARY KEY (rct_id),

  -- [jooq ignore start]
  CONSTRAINT repository_commit_tags_unique
    UNIQUE (rct_tag, rct_commit),
  -- [jooq ignore stop]

  CONSTRAINT repository_commit_tags_commit_exists
    FOREIGN KEY (rct_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Comment>
      The repository_commit_branches table stores information about each branch
      in a repository.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repository_commit_branches (
  rcb_id      BIGINT         NOT NULL GENERATED ALWAYS AS IDENTITY,
  rcb_branch  VARCHAR(8192)  NOT NULL,
  rcb_commit  BIGINT         NOT NULL,

  CONSTRAINT repository_commit_branches_primary_key
    PRIMARY KEY (rcb_id),

  -- [jooq ignore start]
  CONSTRAINT repository_commit_branches_unique
    UNIQUE (rcb_branch, rcb_commit),
  -- [jooq ignore stop]

  CONSTRAINT repository_commit_branches_commit_exists
    FOREIGN KEY (rcb_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Comment>
      The repository_commit_links table stores the links between commits. It
      essentially forms a directed acyclic graph, with each commit pointing to
      the "next" commit that is derived from it. A commit may have multiple
      "next" commits, and nothing here actually enforces the property of being
      acyclic.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE repository_commit_links (
  rcl_commit       BIGINT NOT NULL,
  rcl_commit_next  BIGINT,

  CONSTRAINT repository_commit_links_primary_key
    PRIMARY KEY (rcl_commit, rcl_commit_next),

  CONSTRAINT repository_commit_links_commit_exists
    FOREIGN KEY (rcl_commit) REFERENCES repository_commits (rc_id),

  CONSTRAINT repository_commit_links_commit_next_exists
    FOREIGN KEY (rcl_commit_next) REFERENCES repository_commits (rc_id),

  CONSTRAINT repository_commit_links_next_well_formed
    CHECK (rcl_commit <> rcl_commit_next)
)
]]></Statement>

    <Comment>
      The agents table stores the definitions of agents. Agents are uniquely
      identified by their UUID values, and are also uniquely identified by their
      secret access keys.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE agents (
  a_id           UUID                      NOT NULL,
  a_name         TEXT                      NOT NULL,
  a_access_key   TEXT                      NOT NULL,
  a_last_login   TIMESTAMP WITH TIME ZONE,

  CONSTRAINT agents_primary_key
    PRIMARY KEY (a_id),

  -- [jooq ignore start]
  CONSTRAINT agents_access_key_unique
    UNIQUE (a_access_key),
  -- [jooq ignore stop]

  CONSTRAINT agents_access_key_valid
    CHECK (a_access_key ~ '^[a-f0-9]{64}$')
)
]]></Statement>

    <Comment>
      The agents_environments table stores the most recent set of environment
      variables that have been reported by an agent.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE agents_environments (
  ae_id           UUID   NOT NULL,
  ae_name         TEXT   NOT NULL,
  ae_value        TEXT   NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT agents_environments_primary_key
    PRIMARY KEY (ae_id, ae_name),
  -- [jooq ignore stop]

  CONSTRAINT agents_environments_agent_exists
    FOREIGN KEY (ae_id) REFERENCES agents (a_id)
)
]]></Statement>

    <Comment>
      The agents_properties table stores the most recent set of system
      properties that have been reported by an agent.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE agents_properties (
  ap_id           UUID   NOT NULL,
  ap_name         TEXT   NOT NULL,
  ap_value        TEXT   NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT agents_properties_primary_key
    PRIMARY KEY (ap_id, ap_name),
  -- [jooq ignore stop]

  CONSTRAINT agents_properties_agent_exists
    FOREIGN KEY (ap_id) REFERENCES agents (a_id)
)
]]></Statement>

    <Comment>
      The agent_label_definitions table stores the set of labels that can be
      assigned to agents.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE agent_label_definitions (
  ald_id            BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,
  ald_name          TEXT   NOT NULL,
  ald_description   TEXT   NOT NULL,

  CONSTRAINT agent_label_definitions_primary_key
    PRIMARY KEY (ald_id),

  -- [jooq ignore start]
  ald_name_search TSVECTOR NOT NULL
    GENERATED ALWAYS AS (to_tsvector(%1$S, ald_name)) STORED,

  ald_description_search TSVECTOR NOT NULL
    GENERATED ALWAYS AS (to_tsvector(%1$S, ald_description)) STORED,

  CONSTRAINT agent_label_definitions_name_unique
    UNIQUE (ald_name),
  -- [jooq ignore stop]

  CONSTRAINT agent_label_definitions_name_valid
    CHECK (ald_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Comment>
      The agent_labels table assigns labels to agents.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE agent_labels (
  al_agent   UUID    NOT NULL,
  al_label   BIGINT  NOT NULL,

  CONSTRAINT agent_labels_primary_key
    PRIMARY KEY (al_agent, al_label),

  CONSTRAINT agent_labels_label_exists
    FOREIGN KEY (al_label) REFERENCES agent_label_definitions (ald_id),

  CONSTRAINT agent_labels_agent_exists
    FOREIGN KEY (al_agent) REFERENCES agents (a_id)
)
]]></Statement>

    <Comment>
      The tool_execution_descriptions table stores the tool execution
      descriptions that can be used in plans to execute code on agents.
    </Comment>

    <StatementParameterized parameterInterpolation="STRING_FORMATTING">
      <ParameterReferences>
        <ParameterReference order="0"
                            name="search.language"/>
      </ParameterReferences>
      <Text><![CDATA[
CREATE TABLE tool_execution_descriptions (
  ted_id           BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  ted_name         TEXT    NOT NULL,
  ted_version      BIGINT  NOT NULL,
  ted_tool_name    TEXT    NOT NULL,
  ted_description  TEXT    NOT NULL,
  ted_format       TEXT    NOT NULL,
  ted_text         TEXT    NOT NULL,

  CONSTRAINT tool_execution_descriptions_primary_key
    PRIMARY KEY (ted_id),

  -- [jooq ignore start]
  ted_description_search TSVECTOR NOT NULL
    GENERATED ALWAYS AS (to_tsvector(%1$S, ted_description)) STORED,

  CONSTRAINT tool_execution_descriptions_name_version_unique
    UNIQUE (ted_name, ted_version),
  -- [jooq ignore stop]

  CONSTRAINT tool_execution_descriptions_version_valid
    CHECK (ted_version >= 0),

  CONSTRAINT tool_execution_descriptions_name_valid
    CHECK (ted_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT tool_execution_descriptions_format_name_valid
    CHECK (ted_format ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT tool_execution_descriptions_tool_name_valid
    CHECK (ted_tool_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Text>
    </StatementParameterized>

    <Comment>
      The plans table stores the plan descriptions that can be executed by
      assignments.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE plans (
  p_id        BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  p_name      TEXT    NOT NULL,
  p_version   BIGINT  NOT NULL,
  p_format    TEXT    NOT NULL,
  p_data      BYTEA   NOT NULL,
  p_encoding  TEXT    NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT plans_name_version_unique
    UNIQUE (p_name, p_version),
  -- [jooq ignore stop]

  CONSTRAINT plans_primary_key
    PRIMARY KEY (p_id),

  CONSTRAINT plans_version_valid
    CHECK (p_version >= 0),

  CONSTRAINT plans_format_name_valid
    CHECK (p_format ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT plans_name_valid
    CHECK (p_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Comment>
      The archives table stores information about the archives that are
      generated executing assignments. The actual archive data is stored on
      disk, but information about the archives is stored here.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE archives (
  ar_id            BIGINT                    NOT NULL GENERATED ALWAYS AS IDENTITY,
  ar_token         TEXT                      NOT NULL,
  ar_commit        BIGINT                    NOT NULL,
  ar_hash_algo     TEXT                      NOT NULL,
  ar_hash_value    TEXT                      NOT NULL,
  ar_created       TIMESTAMP WITH TIME ZONE  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT archives_token_unique
    UNIQUE (ar_token),
  -- [jooq ignore stop]

  CONSTRAINT archives_primary_key
    PRIMARY KEY (ar_id),

  CONSTRAINT archives_token_valid
    CHECK (ar_token ~ '^[a-f0-9]{64}$'),

  CONSTRAINT archives_hash_value_valid
    CHECK (ar_hash_value ~ '^[a-f0-9]{64,128}$'),

  CONSTRAINT archives_commit_exists
    FOREIGN KEY (ar_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Comment>
      The assignments table stores assignment definitions. An assignment is
      essentially a promise to compile commits from a given repository using a
      specific plan.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE assignments (
  a_id          BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  a_name        TEXT    NOT NULL,
  a_repository  UUID    NOT NULL,
  a_plan        BIGINT  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT assignments_name_unique
    UNIQUE (a_name),
  -- [jooq ignore stop]

  CONSTRAINT assignments_primary_key
    PRIMARY KEY (a_id),

  CONSTRAINT assignments_repository_exists
    FOREIGN KEY (a_repository) REFERENCES repositories (r_id),

  CONSTRAINT assignments_plan_exists
    FOREIGN KEY (a_plan) REFERENCES plans (p_id),

  CONSTRAINT assignments_name_valid
    CHECK (a_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TYPE assignment_execution_status_t AS ENUM(
  'ASSIGNMENT_EXECUTION_CREATED',
  'ASSIGNMENT_EXECUTION_RUNNING',
  'ASSIGNMENT_EXECUTION_SUCCEEDED',
  'ASSIGNMENT_EXECUTION_FAILED'
);
]]></Statement>

    <Comment>
      The set of assignment executions.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE assignment_executions (
  ae_id          UUID                           NOT NULL,
  ae_assignment  BIGINT                         NOT NULL,
  ae_commit      BIGINT                         NOT NULL,
  ae_created     TIMESTAMP WITH TIME ZONE       NOT NULL,
  ae_started     TIMESTAMP WITH TIME ZONE,
  ae_ended       TIMESTAMP WITH TIME ZONE,
  ae_status      assignment_execution_status_t  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT assignment_executions_status_values_present CHECK (
    CASE
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_CREATED' THEN
        ((ae_started IS NULL) AND (ae_ended IS NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_RUNNING' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_SUCCEEDED' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NOT NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_FAILED' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NOT NULL))
      ELSE
        'f'::boolean
    END
  ),
  -- [jooq ignore stop]

  CONSTRAINT assignment_executions_primary_key
    PRIMARY KEY (ae_id),

  CONSTRAINT assignment_executions_assignment_exists
    FOREIGN KEY (ae_assignment) REFERENCES assignments (a_id),

  CONSTRAINT assignment_executions_commit_exists
    FOREIGN KEY (ae_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TYPE work_item_status_t AS ENUM(
  'WORK_ITEM_CREATED',
  'WORK_ITEM_ACCEPTED',
  'WORK_ITEM_RUNNING',
  'WORK_ITEM_SUCCEEDED',
  'WORK_ITEM_FAILED'
);
]]></Statement>

    <Comment>
      The set of work items in a single assignment execution.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE work_items (
  wi_id         BIGINT              NOT NULL GENERATED ALWAYS AS IDENTITY,
  wi_execution  UUID                NOT NULL,
  wi_name       TEXT                NOT NULL,
  wi_agent      UUID,
  wi_status     work_item_status_t  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT work_items_status_values_present CHECK (
    CASE
      WHEN wi_status = 'WORK_ITEM_CREATED' THEN
        't'::boolean
      WHEN wi_status = 'WORK_ITEM_ACCEPTED' THEN
        (wi_agent IS NOT NULL)
      WHEN wi_status = 'WORK_ITEM_RUNNING' THEN
        (wi_agent IS NOT NULL)
      WHEN wi_status = 'WORK_ITEM_SUCCEEDED' THEN
        (wi_agent IS NOT NULL)
      WHEN wi_status = 'WORK_ITEM_FAILED' THEN
        (wi_agent IS NOT NULL)
      ELSE
        'f'::boolean
    END
  ),
  -- [jooq ignore stop]

  -- [jooq ignore start]
  CONSTRAINT work_items_assignment_item_unique
    UNIQUE (wi_execution, wi_name),
  -- [jooq ignore stop]

  CONSTRAINT work_items_primary_key
    PRIMARY KEY (wi_id),

  CONSTRAINT work_items_assignment_exists
    FOREIGN KEY (wi_execution) REFERENCES assignment_executions (ae_id),

  CONSTRAINT work_items_name_valid
    CHECK (wi_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT work_items_agent_exists
    FOREIGN KEY (wi_agent) REFERENCES agents (a_id)
)
]]></Statement>

    <Comment>
      The logs produced for a single work item. These are the lines of output
      produced on an agent when executing a command.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE work_item_logs (
  wil_id         BIGINT                    NOT NULL GENERATED ALWAYS AS IDENTITY,
  wil_item       BIGINT                    NOT NULL,
  wil_time       TIMESTAMP WITH TIME ZONE  NOT NULL,
  wil_line       TEXT                      NOT NULL,

  CONSTRAINT work_item_logs_primary_key
    PRIMARY KEY (wil_id),

  CONSTRAINT work_item_logs_work_item_exists
    FOREIGN KEY (wil_item) REFERENCES work_items (wi_id)
)
]]></Statement>
  </Schema>

  <Schema versionCurrent="2">
    <Statement><![CDATA[
INSERT INTO scm_providers (
  sp_name,
  sp_description,
  sp_url
) VALUES (
  'com.io7m.northpike.repository.jgit',
  'Eclipse JGit for Git repositories.',
  'https://eclipse.dev/jgit/'
)
]]></Statement>
  </Schema>
</Schemas>
