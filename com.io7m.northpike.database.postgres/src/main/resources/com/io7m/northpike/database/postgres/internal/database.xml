<?xml version="1.0" encoding="UTF-8" ?>

<Schemas xmlns="urn:com.io7m.trasco.database.statements:1:0">

  <Parameters>
    <Parameter name="search.language"
               type="STRING"/>
  </Parameters>

  <Schema versionCurrent="0">
    <Comment>
      The northpike role is a least-privilege role that can perform only those
      operations required to run the system and no others.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The northpike_none role is a no-privilege role that cannot perform any
      actions.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike_none;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike_none WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The northpike_read_only role is a read-only role that cannot write to
      anything.
    </Comment>

    <Statement><![CDATA[
DROP ROLE IF EXISTS northpike_read_only;
]]></Statement>
    <Statement><![CDATA[
CREATE ROLE northpike_read_only WITH NOSUPERUSER NOCREATEDB NOCREATEROLE NOINHERIT NOLOGIN;
]]></Statement>

    <Comment>
      The schema version table stores the current version of the database
      schema. Implementations are expected to query this table on connecting to
      the database in order to ensure that the calling code is compatible with
      the tables in the database.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE schema_version (
  version_lock            CHAR(1) NOT NULL DEFAULT 'X',
  version_application_id  TEXT    NOT NULL,
  version_number          BIGINT  NOT NULL,

  CONSTRAINT check_lock_primary
    PRIMARY KEY (version_lock),

  CONSTRAINT check_lock_locked
    CHECK (version_lock = 'X')
)
]]>
    </Statement>
  </Schema>

  <Schema versionCurrent="1">
    <Comment>
      The users table stores the current set of users. The name field is neither
      authoritative, nor expected to be unique, because the external identity
      server is the authoritative source for names.
    </Comment>

    <Statement><![CDATA[
CREATE TABLE users (
  id    UUID   NOT NULL PRIMARY KEY,
  name  TEXT   NOT NULL,
  roles TEXT[] NOT NULL
)
]]></Statement>

    <Statement>
      GRANT SELECT, INSERT, UPDATE ON users TO northpike
    </Statement>
    <Statement>
      GRANT SELECT ON users TO northpike_read_only
    </Statement>

    <Statement><![CDATA[
CREATE TABLE scm_providers (
  sp_id           BIGINT        NOT NULL GENERATED ALWAYS AS IDENTITY,
  sp_name         VARCHAR(1024) NOT NULL,
  sp_description  TEXT          NOT NULL,
  sp_url          TEXT          NOT NULL,

  CONSTRAINT scm_providers_primary_key
    PRIMARY KEY (sp_id),

  CONSTRAINT scm_providers_name_unique
    UNIQUE (sp_name),

  CONSTRAINT scm_providers_name_valid
    CHECK (sp_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TYPE repository_credentials_type_t AS ENUM(
  'REPOSITORY_CREDENTIALS_USERNAME_PASSWORD',
  'REPOSITORY_CREDENTIALS_NONE'
);
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repositories (
  r_id                       UUID                           NOT NULL,
  r_provider                 BIGINT                         NOT NULL,
  r_url                      VARCHAR(8192)                  NOT NULL,
  r_credentials_type         repository_credentials_type_t  NOT NULL,
  r_credentials_username     VARCHAR(8192),
  r_credentials_password     VARCHAR(8192),
  r_last_successful_update   TIMESTAMP WITH TIME ZONE,

  -- [jooq ignore start]
  CONSTRAINT repositories_credentials_type_values_present CHECK (
    CASE
      WHEN r_credentials_type = 'REPOSITORY_CREDENTIALS_USERNAME_PASSWORD' THEN
        ((r_credentials_username IS NOT NULL) AND (r_credentials_password IS NOT NULL))
      WHEN r_credentials_type = 'REPOSITORY_CREDENTIALS_NONE' THEN
        't'::boolean
      ELSE
        'f'::boolean
    END
  ),
  -- [jooq ignore stop]

  CONSTRAINT repositories_primary_key
    PRIMARY KEY (r_id),

  CONSTRAINT repositories_provider_exists
    FOREIGN KEY (r_provider) REFERENCES scm_providers (sp_id),

  CONSTRAINT repositories_url_unique
    UNIQUE (r_url)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repository_commit_authors (
  rca_id     BIGINT   NOT NULL GENERATED ALWAYS AS IDENTITY,
  rca_name   TEXT     NOT NULL,
  rca_email  TEXT     NOT NULL,

  CONSTRAINT repository_commit_authors_primary_key
    PRIMARY KEY (rca_id)
)
]]></Statement>

    <Statement><![CDATA[
-- [jooq ignore start]
CREATE UNIQUE INDEX repository_commit_authors_unique
  ON repository_commit_authors (rca_name, LOWER(rca_email))
-- [jooq ignore stop]
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repository_commits (
  rc_id                     BIGINT                    NOT NULL GENERATED ALWAYS AS IDENTITY,
  rc_repository             UUID                      NOT NULL,
  rc_commit_id              VARCHAR(8192)             NOT NULL,
  rc_commit_time_created    TIMESTAMP WITH TIME ZONE  NOT NULL,
  rc_commit_time_received   TIMESTAMP WITH TIME ZONE  NOT NULL,
  rc_commit_author          BIGINT                    NOT NULL,
  rc_commit_message_subject TEXT                      NOT NULL,
  rc_commit_message_body    TEXT                      NOT NULL,

  CONSTRAINT repository_commits_primary_key
    PRIMARY KEY (rc_id),

  CONSTRAINT repository_commits_unique
    UNIQUE (rc_repository, rc_commit_id),

  CONSTRAINT repository_commits_repository_exists
    FOREIGN KEY (rc_repository) REFERENCES repositories (r_id),

  CONSTRAINT repository_commits_author_exists
    FOREIGN KEY (rc_commit_author) REFERENCES repository_commit_authors (rca_id),

  CONSTRAINT repository_commits_id_valid
    CHECK (rc_commit_id ~ '^[a-f0-9]+$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repository_commit_tags (
  rct_id      BIGINT         NOT NULL GENERATED ALWAYS AS IDENTITY,
  rct_tag     VARCHAR(8192)  NOT NULL,
  rct_commit  BIGINT         NOT NULL,

  CONSTRAINT repository_commit_tags_primary_key
    PRIMARY KEY (rct_id),

  -- [jooq ignore start]
  CONSTRAINT repository_commit_tags_unique
    UNIQUE (rct_tag, rct_commit),
  -- [jooq ignore stop]

  CONSTRAINT repository_commit_tags_commit_exists
    FOREIGN KEY (rct_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repository_commit_branches (
  rcb_id      BIGINT         NOT NULL GENERATED ALWAYS AS IDENTITY,
  rcb_branch  VARCHAR(8192)  NOT NULL,
  rcb_commit  BIGINT         NOT NULL,

  CONSTRAINT repository_commit_branches_primary_key
    PRIMARY KEY (rcb_id),

  -- [jooq ignore start]
  CONSTRAINT repository_commit_branches_unique
    UNIQUE (rcb_branch, rcb_commit),
  -- [jooq ignore stop]

  CONSTRAINT repository_commit_branches_commit_exists
    FOREIGN KEY (rcb_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE repository_commit_links (
  rcl_commit       BIGINT NOT NULL,
  rcl_commit_next  BIGINT,

  CONSTRAINT repository_commit_links_primary_key
    PRIMARY KEY (rcl_commit, rcl_commit_next),

  CONSTRAINT repository_commit_links_commit_exists
    FOREIGN KEY (rcl_commit) REFERENCES repository_commits (rc_id),

  CONSTRAINT repository_commit_links_commit_next_exists
    FOREIGN KEY (rcl_commit_next) REFERENCES repository_commits (rc_id),

  CONSTRAINT repository_commit_links_next_well_formed
    CHECK (rcl_commit <> rcl_commit_next)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE agents (
  a_id           UUID                      NOT NULL,
  a_name         TEXT                      NOT NULL,
  a_access_key   TEXT                      NOT NULL,
  a_last_login   TIMESTAMP WITH TIME ZONE,

  CONSTRAINT agents_primary_key
    PRIMARY KEY (a_id),

  -- [jooq ignore start]
  CONSTRAINT agents_access_key_unique
    UNIQUE (a_access_key),
  -- [jooq ignore stop]

  CONSTRAINT agents_access_key_valid
    CHECK (a_access_key ~ '^[a-f0-9]{64}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE agents_environments (
  ae_id           UUID   NOT NULL,
  ae_name         TEXT   NOT NULL,
  ae_value        TEXT   NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT agents_environments_primary_key
    PRIMARY KEY (ae_id, ae_name),
  -- [jooq ignore stop]

  CONSTRAINT agents_environments_agent_exists
    FOREIGN KEY (ae_id) REFERENCES agents (a_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE agents_properties (
  ap_id           UUID   NOT NULL,
  ap_name         TEXT   NOT NULL,
  ap_value        TEXT   NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT agents_properties_primary_key
    PRIMARY KEY (ap_id, ap_name),
  -- [jooq ignore stop]

  CONSTRAINT agents_properties_agent_exists
    FOREIGN KEY (ap_id) REFERENCES agents (a_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE agent_label_definitions (
  ald_id            BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,
  ald_name          TEXT   NOT NULL,
  ald_description   TEXT   NOT NULL,

  CONSTRAINT agent_label_definitions_primary_key
    PRIMARY KEY (ald_id),

  -- [jooq ignore start]
  CONSTRAINT agent_label_definitions_name_unique
    UNIQUE (ald_name),
  -- [jooq ignore stop]

  CONSTRAINT agent_label_definitions_name_valid
    CHECK (ald_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE agent_labels (
  al_agent   UUID    NOT NULL,
  al_label   BIGINT  NOT NULL,

  CONSTRAINT agent_labels_primary_key
    PRIMARY KEY (al_agent, al_label)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE tool_execution_descriptions (
  ted_id         BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  ted_name       TEXT    NOT NULL,
  ted_version    BIGINT  NOT NULL,
  ted_tool_name  TEXT    NOT NULL,
  ted_format     TEXT    NOT NULL,
  ted_text       TEXT    NOT NULL,

  CONSTRAINT tool_execution_descriptions_primary_key
    PRIMARY KEY (ted_id),

  -- [jooq ignore start]
  CONSTRAINT tool_execution_descriptions_name_version_unique
    UNIQUE (ted_name, ted_version),
  -- [jooq ignore stop]

  CONSTRAINT tool_execution_descriptions_version_valid
    CHECK (ted_version >= 0),

  CONSTRAINT tool_execution_descriptions_name_valid
    CHECK (ted_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT tool_execution_descriptions_format_name_valid
    CHECK (ted_format ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT tool_execution_descriptions_tool_name_valid
    CHECK (ted_tool_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE plans (
  p_id        BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  p_name      TEXT    NOT NULL,
  p_version   BIGINT  NOT NULL,
  p_format    TEXT    NOT NULL,
  p_data      BYTEA   NOT NULL,
  p_encoding  TEXT    NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT plans_name_version_unique
    UNIQUE (p_name, p_version),
  -- [jooq ignore stop]

  CONSTRAINT plans_primary_key
    PRIMARY KEY (p_id),

  CONSTRAINT plans_version_valid
    CHECK (p_version >= 0),

  CONSTRAINT plans_format_name_valid
    CHECK (p_format ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$'),

  CONSTRAINT plans_name_valid
    CHECK (p_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE archives (
  ar_id            BIGINT                    NOT NULL GENERATED ALWAYS AS IDENTITY,
  ar_token         TEXT                      NOT NULL,
  ar_commit        BIGINT                    NOT NULL,
  ar_hash_algo     TEXT                      NOT NULL,
  ar_hash_value    TEXT                      NOT NULL,
  ar_created       TIMESTAMP WITH TIME ZONE  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT archives_token_unique
    UNIQUE (ar_token),
  -- [jooq ignore stop]

  CONSTRAINT archives_primary_key
    PRIMARY KEY (ar_id),

  CONSTRAINT archives_token_valid
    CHECK (ar_token ~ '^[A-F0-9]{64}$'),

  CONSTRAINT archives_hash_value_valid
    CHECK (ar_hash_value ~ '^[A-F0-9]{64,128}$'),

  CONSTRAINT archives_commit_exists
    FOREIGN KEY (ar_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE assignments (
  a_id          BIGINT  NOT NULL GENERATED ALWAYS AS IDENTITY,
  a_name        TEXT    NOT NULL,
  a_repository  UUID    NOT NULL,
  a_plan        BIGINT  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT assignments_name_unique
    UNIQUE (a_name),
  -- [jooq ignore stop]

  CONSTRAINT assignments_primary_key
    PRIMARY KEY (a_id),

  CONSTRAINT assignments_repository_exists
    FOREIGN KEY (a_repository) REFERENCES repositories (r_id),

  CONSTRAINT assignments_plan_exists
    FOREIGN KEY (a_plan) REFERENCES plans (p_id),

  CONSTRAINT assignments_name_valid
    CHECK (a_name ~ '^([a-z][a-z0-9_-]{0,63})(\.[a-z][a-z0-9_-]{0,62}){0,15}$')
)
]]></Statement>

    <Statement><![CDATA[
CREATE TYPE assignment_execution_status_t AS ENUM(
  'ASSIGNMENT_EXECUTION_CREATED',
  'ASSIGNMENT_EXECUTION_RUNNING',
  'ASSIGNMENT_EXECUTION_SUCCEEDED',
  'ASSIGNMENT_EXECUTION_FAILED'
);
]]></Statement>

    <Statement><![CDATA[
CREATE TABLE assignment_executions (
  ae_id          UUID                           NOT NULL,
  ae_assignment  BIGINT                         NOT NULL,
  ae_commit      BIGINT                         NOT NULL,
  ae_created     TIMESTAMP WITH TIME ZONE       NOT NULL,
  ae_started     TIMESTAMP WITH TIME ZONE,
  ae_ended       TIMESTAMP WITH TIME ZONE,
  ae_status      assignment_execution_status_t  NOT NULL,

  -- [jooq ignore start]
  CONSTRAINT assignment_executions_status_values_present CHECK (
    CASE
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_CREATED' THEN
        ((ae_started IS NULL) AND (ae_ended IS NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_RUNNING' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_SUCCEEDED' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NOT NULL))
      WHEN ae_status = 'ASSIGNMENT_EXECUTION_FAILED' THEN
        ((ae_started IS NOT NULL) AND (ae_ended IS NOT NULL))
      ELSE
        'f'::boolean
    END
  ),
  -- [jooq ignore stop]

  CONSTRAINT assignment_executions_primary_key
    PRIMARY KEY (ae_id),

  CONSTRAINT assignment_executions_assignment_exists
    FOREIGN KEY (ae_assignment) REFERENCES assignments (a_id),

  CONSTRAINT assignment_executions_commit_exists
    FOREIGN KEY (ae_commit) REFERENCES repository_commits (rc_id)
)
]]></Statement>
  </Schema>
</Schemas>
